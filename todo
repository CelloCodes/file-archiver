reimplementar loop que passar pelos argumentos livres
    feito

ordenar por nome ou por indice no arquivo?
vantagens de ordenar por nome:
    velocidade na hora de verificar presenca de um membro
vantagens de ordenar por indice:
    velocidade na hora de imprimir e extrair todos
ideia:
    estrutura de arvore mista, com lista ligada entre os nodos
    formando a sequencia de insercao
    feito

descobrir como funciona delecao de dados do arquivo
(mover o ponteiro do fim do arquivo?)

processo 1: atualizacao de um membro presente no arquivo
    verificar diferenca no tamanho das versoes do membro
    membros subsequentes sao movidos esta diferenca de bytes
    comecando pelo final do ultimo membro
    depois do espaco ter sido ajustado, membro antigo eh sobrescrito

processo 2: troca de posicao de dois membros adjacentes
    verificase qual o maior membro
    caso nao haja, os bytes sao simplesmente trocados
    caso haja, a diferenca do tamanho eh calculada
    chamando a diferenca de D, em seguida os bytes do membro
    sao movidos D bytes para o fim, ate chegar nos D bytes finais
    como os D bytes finais nao podem ser movidos em direcao ao fim
    sao movidos para o comeco de onde era o arquivo
    efetivamente o arquivo inteiro e movido D bytes para a direita
    mas os D bytes finais sao trazidos para a frente
    por fim os dados sao atualizados
    a forma e:
        os primeiros X bytes dos D bytes finais do membro sao lidos
        entao todos os bytes do do membro do 0 ate antes dos D bytes finais
        sao lidos e escritos X bytes para a direita de X em X bytes
        por fim os X bytes lidos dos D bytes finais sao escritos no espaco
        que se abriu no comeco do membro e o processo eh repetido para os bytes
        seguintes
        processo pode se chamar prepareMember ou reorderSingleMember

processo 3: movimentacao de um membro
    obtem o indice que o membro a ser movido deve obter
    em seguida troca o membro de posicao com o membro de proximo
    indice no sentido do indice obtido usando o processo 2
    3 repete-se o processo ate o membro a ser movido obter o indice desejado

-i
    loop que verifica a presenca dos membros indicados na linha de comando
    membros encontrados passam pelo processo 1
    membros nao encontrados sao inseridos em ordem no final do arquivo

-a
    mesmo processo do -i, porem verifica-se se a data de modificacao do membro
    mudou antes de aplicar o processo 1

sobre a movimentacao:
    a movimentacao so interfere na ordem dos arquivos contidos dentro do
    intervalo da movimentacao. ou seja, do membro mais a esquerda ate o membro
    mais a direita que estao envolvidos na movimentacao. o resto nao sera
    afetado pela movimentacao, seja em ordem ou posicao no archive

-m
    verifica a presenca dos dois membros indicados
    em seguida, executa o processo 3

sobre a remocao:
    necessario "mover" os bytes que serao removidos para o final do arquivo e 
    entao truncar o arquivo
    na verdade a informacao removida sera sobrescrita, deixando bytes
    desatualizados no final do arquivo, que sera entao truncado
    para isso e necessario saber onde o arquivo efetivamente termina
    posicao no arquivo do ultimo membro mais seu tamanho mais o tamanho
    da sessao diretorio 
    porem como nao deve ser facil saber o tamanho da sessao diretorio
    usar ftell depois da funcao de escrever o diretorio
    aparentemente o ponteiro de arquivo e preservado em diferentes contextos
    lembrar de testar

-x e -r
    x e r funcionaram da mesma forma, com o adicional de que x ira escrever
    os membros antes
    os membros a serem removidos/extraidos serao apagados da estrutura
    diretorio, com a informacao do primeiro membro que sucessede um membro
    excluido sendo preservada
    esse membro entao sera movido para a posicao do membro removido
    o membro seguinte sera movido para a posicao do ponteiro do arquivo
    e o processo se repete ate que todos os membros tenham sido movidos
    para a esquerda

PROXIMOS PASSOS
    implementar -m
